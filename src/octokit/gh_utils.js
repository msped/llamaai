import { getOctokit } from "@/octokit/octokit";
import { createHmac } from "crypto";

// Function to fetch issue details
export async function fetchIssueDetails(owner, repo, issue_number) {
    const { data } = await getOctokit.issues.get({
        owner,
        repo,
        issue_number,
    });
    return data;
}

  // Function to create a branch
export async function createBranch(owner, repo, base, newBranchName) {
    const { data: refData } = await getOctokit.git.getRef({
        owner,
        repo,
        ref: `heads/${base}`,
    });
    await getOctokit.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${newBranchName}`,
        sha: refData.object.sha,
    });
}

  // Function to create files and commit
export async function createFilesAndCommit(owner, repo, branch, pathsContentsMap) {
    for (const [path, content] of Object.entries(pathsContentsMap)) {
        await getOctokit.repos.createOrUpdateFileContents({
            owner,
            repo,
            path,
            message: `Update ${path}`,
            content: Buffer.from(content).toString('base64'),
            branch,
        });
    }
}

  // Function to create a pull request
export async function createPullRequest(owner, repo, title, head, base, body) {
    const { data } = await getOctokit.pulls.create({
        owner,
        repo,
        title,
        head,
        base,
        body,
    });
    return data;
}

export async function processAssignedIssue(payload) {
    // Ideally comment to say got it, in queue

    const { issue, repository } = payload;
    const owner = repository.owner.login;
    const repo = repository.name;
    const issueNumber = issue.number;
    const issueLabels = issue.labels.map(label => label.name).join('-');


    try {
        // Analyze repository structure
        const dirStructure = await fetchRepositoryStructure(owner, repo);
    
        // Get AI-generated code (simulated here)
        const { filePath, content } = await generateCodeWithAI(issue.title, dirStructure);
    
        // Handle git operations
        const branchName = `llama-${issueLabels}-${issueNumber}`;
        await createBranch(owner, repo, 'main', branchName);
        await createFilesAndCommit(owner, repo, branchName, { [filePath]: content });
        await createPullRequest(
            owner, 
            repo, 
            `Fix for issue #${issueNumber}`, 
            branchName, 
            'main', 
            'Code generated by LlamaAI. This code has not been reviewed, \
            please review and test it before merging.'
        );
        
        // Should send an email
        console.log('Pull request created successfully.');
    } catch (error) {
        // Should send an email or save to db maybe?
        console.error('Failed to process issue:', error);
    }
}

export async function fetchRepositoryStructure(owner, repo) {
    const { data: contents } = await octokit.repos.getContent({
        owner,
        repo,
        path: '', // root directory
    });
    return contents.filter(item => item.type === 'dir').map(dir => dir.path);
}

export async function generateCodeWithAI(issueTitle, dirStructure) {
    // Simulate AI code generation logic
    // Ideally, this would involve calling an AI API with the issue title and directory structure

    // Placeholder: simple logic to determine file path
    const filePath = `${dirStructure.find(dir => dir.includes('src') || dir === '')}/fix.js`;
    const content = `// Auto-generated fix for: ${issueTitle}\nconsole.log('Fix applied');`;

    return { filePath, content };
}

export function validateSignature(payload, signature) {
    const hmac = createHmac('sha256', process.env.GITHUB_WEBHOOK_SECRET);
    const digest = `sha256=${hmac.update(payload).digest('hex')}`;
    return digest === signature;
}