import { updateIssue } from "./data/issues";
import createIssueComment from "./utils/create-issue-comment";
import { generateContent } from "@/gemini/getCodeResponse";

// Function to fetch issue details
export const fetchIssueDetails = async (octokit, owner, repo, issue_number) => {
    const { data } = await octokit.request("GET /repos/{owner}/{repo}/issues/{issue_number}", {
        owner,
        repo,
        issue_number,
    });
    return data;
}

// Function to create a branch
export const createOrGetBranch = async (octokit, owner, repo, base, newBranchName) => {
    let refData;

    try {
        const response = await octokit.request("GET /repos/{owner}/{repo}/git/ref/{ref}", {
            owner,
            repo,
            ref: `heads/${newBranchName}`,
        });
        refData = response.data;
        return refData;
    } catch (error) {
        try {
            const response = await octokit.request("GET /repos/{owner}/{repo}/git/ref/{ref}", {
                owner,
                repo,
                ref: `heads/${base}`,
            });
            refData = response.data;
            await octokit.request("POST /repos/{owner}/{repo}/git/refs", {
                owner,
                repo,
                ref: `refs/heads/${newBranchName}`,
                sha: refData.object.sha,
            });
        } catch (error) {
            console.error('Failed to create branch:', error);
        }
    }
}

// Function to create files and commit
export const createFilesAndCommit = async (octokit, owner, repo, branch, files) => {
    for (const {filePath: path, contents, commitMessage} of files) {
        try {
            await octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", {
                owner,
                repo,
                path,
                message: commitMessage,
                content: Buffer.from(contents).toString('base64'),
                branch,
            });
        } catch (error) {
            console.error('Failed to create file:', error);
        }
    }
}

// Function to create a pull request
export const createPullRequest = async (octokit, owner, repo, title, head, base, body, issue) => {
    try {
        const { data } = await octokit.request("POST /repos/{owner}/{repo}/pulls", {
            owner,
            repo,
            title,
            head,
            base,
            body,
            maintainer_can_modify: true,
            issue
        });
        return data;
    } catch (error) {
        console.error('Failed to create pull request:', error);
    }
}

export const processAssignedIssue = async (octokit, payload) => {
    const { issue, repository } = payload;
    const owner = repository.owner.login;
    const repo = repository.name;
    const issueNumber = issue.number;
    const issueLabels = issue.labels.map(label => label.name).join('-');

    createIssueComment(
        octokit,
        owner,
        repo,
        issueNumber,
        "We have received your request and will look to provide a solution. \n\n" +
        "Your request has been placed into a queue. Once completed, we will send " +
        "you a pull request to review."
    )

    try {
        // Get AI-generated files
        const files = await generateCodeWithAI(octokit, issue, repository);
    
        // Handle git operations
        const branchName = `llama-${issueLabels}-${issueNumber}`;
        await createOrGetBranch(octokit, owner, repo, 'main', branchName);
        await createFilesAndCommit(octokit, owner, repo, branchName, files);
        const pullRequest = await createPullRequest(
            octokit,
            owner, 
            repo, 
            `Fix for issue #${issueNumber}`, 
            branchName,
            'main', 
            'Code generated by LlamaAI. This code has not been reviewed, ' +
            'please review and test it before merging.',
            issueNumber
        );
        
        // Should update db to show as completed & link with pull
        // request ID?
        if(pullRequest.id){
            await updateIssue(issue.id, { open: false })
            createIssueComment(
                octokit,
                owner,
                repo,
                issueNumber,
                `LlamaAI has sent a pull request with a solution.`
            )
            console.log('Pull request created successfully.');
        } else {
            console.error()
        }
    } catch (error) {
        // Should send an email or save to db maybe?
        console.error('Failed to process issue:', error);
    }
}

// Function to request code from Gemini
export const generateCodeWithAI = async(octokit, issue, repository) => {
    const files = await generateContent(octokit, issue, repository);
    if (!files) throw new Error('Failed to generate code.');
    return files;
}

// Function to send the initial message to user
export const requestIssueMessage = async (octokit, payload) => {
    const { repository, issue } = payload;
    await createIssueComment(
        octokit,
        repository.owner.login,
        repository.name,
        issue.number,
        "Would you like LlamaAI to provide a solution to this issue? \n\n" +
        "Please comment with: \n\n" +
        "1. Yes - LlamaAI will generate a solution and create a pull request.\n" +
        "2. No - LlamaAI will not provide any solution. \n\n" +
        "> [!IMPORTANT]\n" +
        "> Only the repository owner can request LlamaAI to provide a solution." 
    )
}